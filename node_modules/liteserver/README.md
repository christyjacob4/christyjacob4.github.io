## liteserver 

    liteserver 是一个轻量级的http服务器。
    liteserver 扩展了 request对象，response对象，使得编写web应用更简单。
    
    liteserver集成了常用的http输入接口（get，post，cookie）和输出接口(模板引擎、json输入，jsonp输出)
    程序则关心控制的编写即可
    
    liteserver可方便的结合cluster使用，以创建多进程服务

## 使用方法

#### 安装模块
  
    npm install liteserver

#### 编写控制器
    
    每个控制器接收三个参数: request response config

    function index(req,res,config){ // 每个控制器，接收三个
      var router = req.getRouter();
      console.log(router);
    }
    exports = module.exports = index;

#### 编写服务index.js 

    var LiteServer = require('liteserver');
    var Log = LiteServer.Log;
    var serv = LiteServer.create(cfg);  // cfg 参考config配置一节
    var controller = serv.loadController(path); // 从path路径加载控制器，path下所有的js文件，以及目录
    serv.router({
      '/index' : controller.index,
      '/favicon' : serv.favicon(icopath),
      '/custom':function(req,res,cfg){
        // 快速定义一枚controller 
      }
    }).view({
      constant : {js : 'http://static.abc/js'}
      compress : true, // compress output html
      debug:debug, // true or false 
    }).start(function(err){
      if(err){
        console.log(err);
      }else{
        console.log('server start!');
      }
    });

## config 配置

    config对象

    {
      root: string 服务所在的路径 ，加载控制器、模板等等，都依赖此路径
      port: string 服务端口，目前只支持单个端口的绑定。多端口暂不考虑
      tpl: path 模板存放地址，相对于root的地址或者绝对地址，注意path "/"开头,表示绝对地址
      debug: bool 是否调试状态
    }

    配置模板引擎

    serv.setView(viewObject); // viewObject 必须实现 render('tpl',{obj}) 方法

    配置路由解析器

    serv.setRouter(function(){
      // TODO your own router parser
    })

    配置 filter, filter在router之前执行，相当于入户的电表开关，可以控制访问权限
    serv.filter(function (req, res, config, next) {
      // if allow
    });
    配置log模块, 两组log文件，不同的log等级，按天切分

    Log.create({
      sys : {
        file : './logs/test.%year%-%month%-%day%.log',
        level : 'DEBUG',
        duration : 4
      },
      login : {
        file : './logs/test.%year%-%month%-%day%.log',
        level : 'WARN',
        duration : 4
      }
    });

## 路由规则

    http://domain/controller/action/param[0]/param[1]/param[...]
    上面可以看出，所有的请求路径都被映射成controller、action、param三部分
    通过req.getRouter()获得这个router对象
    某些情况，用户请求地址到controller，则会有默认的action响应，这由controller来控制
    action往下的路由是自由的，controller自行控制
    
    var router = req.getRouter()
    
## req对象的扩展

    var router = req.getRouter()  // 获取路由信息
    var get = req.getQuery()      // 获取get参数，注意数据值没有decodeURIComponent()过，按需处理
    var cookie = req.getCookie()  // 获取cookie，注意数据值没有decodeURIComponent()过，按需处理
    
    req.getPost(function(err, post, files){   // 获取简单post的数据，回调函数的形式
      console.log(post);
    });
    
    req.on('post',function(err, post, files){  // 获取简单post的数据，事件形式
      console.log(post);
    });
    req.getPost();
    
    req.dispatch(actionName, {
      // req分发请求动作，有actionName来指定调用的具体的action方法，注意action方法$开头
      $default : function (req, res, config) {
        // $default 方法必须有
      },
      $test : function (req, res, config) {

      }
    }); 
    
## res对象的扩展

    res.render(tpl, obj)     // 渲染模板，tpl为模板文件相对地址（相对模板的目录），obj为模板中的变量，注意这里直接res.end()了
    res.setCookie(name, value, option) // 设置cookie,  option为对象{expires,path,domain,httponly}
    res.redirect(path)      // path == string 为 302 ， path为router对象，则直接在服务器端跳转至相应的controller.action
    res.json(obj)           // json输出，注意这里直接 res.end()了，不能再继续http输出
    res.jsonp(cb, obj)       // jsonp格式输出，注意这里直接res.end()了，不能再有http输出
    res.gzip(obj)           // gzip输出, 支持 obj 为 Object(自动JSON输出) 或者 String ,stream模式需自行编写

## 自定义错误返回
    
    目前支持两种错误自定义
    当controller没找到时：
      404 handler将被触发；
    当controller执行过程中，发生意外的时候：
      500 handler将被触发；

    注册错误handler
    serv.router({
      '500' : function (req, res, config) {
        var err = req.error; // get error object
        // TODO handle error
      },
      '404' : function (req, res, config) {

      }
    });

## log日志系统
    
    var log = require('liteserver').Log.create({
      sys : {
        file : './logs/test.%year%-%month%-%day%.log',  // 支持按天、月、年分割
        level : 'DEBUG', // can be DEBUG|INFO|TRACE|WARN|ERROR|FATAL|OFF
        duration : 4
      },
      login : {
        file : './logs/test.%year%-%month%-%day%.log',
        level : 'WARN',
        duration : 4
      },
      std : {           // without file, log will write to process.stdout by default 
        level : 'DEBUG' 
      }
    });

    log对象包含以下方法：
        log.debug(msg)
        log.trace(msg)
        log.info(msg)
        log.warn(msg)
        log.error(msg)
        log.fatal(msg)

#### 测试

    mocha test --coverage
