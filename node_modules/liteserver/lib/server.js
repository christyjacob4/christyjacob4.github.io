/**
 * Class Server
 */
var Path = require('path');
var View = require('liteview');
var Fs = require('fs');
var HTTP = require('http');

var ifDebug = false;

function output() {
  if (!ifDebug) {
    return;
  }
  Array.prototype.unshift.apply(arguments, [getDate(), '[liteserver]']);
  console.log.apply(console, arguments);
}

function getDate() {
  var dd = new Date();
  var y = dd.getFullYear();
  var m = dd.getMonth();
  var d = dd.getDate();
  var H = dd.getHours();
  var i = dd.getMinutes();
  var s = dd.getSeconds() + dd.getMilliseconds() / 1000;
  s = s.toFixed(3);
  m = m > 9 ? m : '0' + m;
  d = d > 9 ? d : '0' + d;
  H = H > 9 ? H : '0' + H;
  i = i > 9 ? i : '0' + i;
  s = s > 9 ? s : '0' + s;
  return '[' + y + '-' + m + '-' + d + ' ' + H + ':' + i + ':' + s + ']';
}
/**
 * Class Server
 * @param {Object} cfg
 *  cfg have properties bellow
 *  {
 *    root : {Path} the server root
 *    tpl  : {Path} the tpl path, relative to root , or an abs path
 *    port : {Number|filePath} server port
 *    cancelListen : {bool} do not listen port , for module:pm using
 *    timeout : {Number} ms
 *    maxPost : {Number} byte
 *    debug : {bool}
 *  }
 */
function Server(cfg) {
  // set global debug flag
  ifDebug = cfg.debug;

  output('init server');

  this.cfg = cfg;
  this.root = cfg.root;
  // set Post
  HTTP.IncomingMessage.prototype.MAX_POST_FIELDS = cfg.maxPostFields;
  HTTP.IncomingMessage.prototype.MAX_POST_FIELDSSIZE = cfg.maxPostFieldsSize;
  HTTP.IncomingMessage.prototype.POST_TMP_DIR = cfg.postTmpDir;
  HTTP.ServerResponse.prototype.REDIRECT_ACCESS = cfg.redirectAccess ? cfg.redirectAccess : {};
  // set default timeout
  cfg.timeout = cfg.timeout ? cfg.timeout : 15000; // 15s

  this.routermap = {};
  this.viewEngin = View.create();
  this._filter = function (req, res, config, next) {
    next(true);
  };
  this.serv = null;
  if (cfg.tpl) {
    if (! /^\//.test(cfg.tpl) && cfg.tpl) {
      cfg.tpl = Path.join(cfg.root, cfg.tpl);
    }
    output('using inner viewEngin');
    this.viewEngin.init(cfg.tpl);
  } else {
    this.viewEngin.render = function () {
      throw new Error('view is not inited ! please re-config the server.');
    };
  }
}

Server.prototype = {
  /**
   * config the view engine
   * @param  {Object} cfg
   *    cfg can be :
   *    {
   *      tpl : <Path> the tpl path
   *      debug : <bool> , if open debug
   *      compress : <bool> , if compress the output html into one line string
   *      constant : <Object>, the server constant object
   *    }
   * @return server instance
   */
  view : function (cfg) {
    var view = this.viewEngin;
    if (cfg.tpl) {
      view.init(cfg.tpl);
    }
    if (cfg.debug !== undefined) {
      view.debug(cfg.debug);
    }
    if (cfg.compress !== undefined) {
      view.compress(cfg.compress);
    }
    if (cfg.constant) {
      view.constant(cfg.constant);
    }
    return this;
  },
  /**
   * setView , the view engin
   * @param {View} view the tpl engine
   *
   * view must implement:
   *   view.render(tpl, {key:value});
   */
  setView : function (view) {
    output('custom viewEngin');
    if (!view.render || view.render.length < 2) {
      throw new Error('liteserver setView(view), view must implement view.render(tpl,obj)!');
    }
    this.viewEngin = view;
    return this;
  },
  /**
   * setLog obj , Deprecated!!!
   * @param {Object} logger
   * @param {String} name
   */
  setLog : function () {
    return this;
  },
  /**
    更改 getRouter(fn) 方法
      fn : function(url){return parsedObj}
  */
  setRouter : function (fn) {
    output('custom router parser');
    HTTP.IncomingMessage.prototype.getRouter = fn;
    return this;
  },
  /**
   * init the server's router rules
   * @param  {Object} rules
   *         rules can be
   *         {
   *           '500' : function (req, res, config) {}
   *           '=500':   same as '500'
   *           '/path' : function (req, res, config) {}
   *         }
   * @return server instance
   */
  router : function (rules) {
    output('parse router rules');
    var n = null;
    var matches = []; // match router
    var named = {};   // named router
    var debug = this.cfg.debug;
    for (var i in rules) {
      if ((i + '').match(/^\d+$/)) {
        // rule name is a number
        named[i] = rules[i];
        continue;
      } else {
        n = i.trim();
        n = n.replace(/\./g, '\\.').replace(/\*/g, '.*');
        if (n.indexOf('/') === 0) {
          n = '^' + n;
        }
        if (!n.match(/\$$/)) {
          n += '(/|$)';
        }
        matches.push([new RegExp(n), rules[i]]);
      }
    }
    // default 404 response
    if (!named['404']) {
      named['404'] = function (req, res) {
        res.statusCode = 404;
        res.setHeader('Content-Type', 'text/html; charset=utf-8');
        res.done('<h2>404,Page not found!</h2>');
        output('controller not found', req.url);
      };
    }
    // default 500 response
    if (!named['500']) {
      named['500'] = function (req, res) {
        var err = req.error;
        res.statusCode = 500;
        res.setHeader('Content-Type', 'text/html; charset=utf-8');
        res.end('<h2>500,Server error!</h2>', debug ? err.stack : '');
        output('controller error:', req.url, err.stack);
      };
    }
    this.routermap = {
      matches: matches,
      named: named
    };
    return this;
  },
  /**
   * addfilter for request
   * @public
   * @param  {Array} obj [description]
   * @return {Object}     [description]
   */
  filter: function (func) {
    if (func) {
      this._filter = func;
    }
    return this;
  },
  /**
   * load Controllers from dirs
   * @public
   * @param  {Path} base    the controller's dir , can be relative path(based on root) or abs path
   * @param  {Array} exclude the exclude list , filename without suffix (.js)
   * @return {Object}  controllers Object
   */
  load: function (base, exclude) {
    output('load controllers');
    var p;
    if (/^\//.test(base)) {
      p = base;
    } else {
      p = Path.join(this.root, base);
    }
    var controllers;
    try {
      controllers = Fs.readdirSync(p);
    } catch (e) {
      e.message = 'load controllers error: read controller\'s base error ' + e.message;
      throw e;
    }
    var res = {};
    var name;
    var _exclude  = {};
    if (!Array.isArray(exclude)) exclude = [];
    exclude.forEach(function (v) {
      _exclude[v] = true;
    });
    for (var i = 0 ; i < controllers.length ; i++) {
      // ignore .xxx file
      if (controllers[i].match(/^\./)) {
        continue;
      }
      // remove file suffix
      name = controllers[i].replace(/\.\w+$/, '');
      // check exclude
      if (_exclude[name]) {
        output('\t>> controller exclude:', name);
        continue;
      }
      try {
        res[name] = require(Path.join(p, name));
        output('\t>> controller loaded:', name);
        if (!res[name] || typeof res[name] !== 'function' || res[name].length < 2) {
          output('warn, controller "' + controllers[i] + '" is empty or not correct!');
        }
      } catch (e) {
        e.message = '\t>> controller error:' + e.message;
        throw e;
      }
    }
    return res;
  },
  /**
   * start server
   * this function will create http server ,and try to listen port if port is given and cancelListen === false
   * @public
   * @param  {Function} cb  the http listen callback
   * @return server instance
   */
  start: function (cb) {
    var cfg = this.cfg;
    this.serv = HTTP.createServer(createServerHandler(this._filter, this.routermap, this.viewEngin, cfg));
    if (!cfg.cancelListen && cfg.port) {
      this.serv.listen(cfg.port, function (err) {
        if (err) {
          output('fail to start server', err);
        } else {
          output('start server');
        }
        cb && cb(err);
      });
    }
    return this;
  },
  /**
   * stop server
   * @public
   * @param  {Function} cb callback
   */
  stop: function (cb) {
    output('stop server');
    this.serv.close(cb);
  },
  /**
   * return server Instance
   * @public
   * @return {HttpServer}
   */
  getServer: function () {
    return this.serv;
  }
};

function createServerHandler(filter, router, view, config) {
  // match router
  var matches = router.matches;
  // named router
  var named = router.named;
  var timeout = config.timeout;
  config = config ? config : {};

  return function (req, res) {
    var url = req.url;
    var hasQuery;
    var flag = false;
    // remove query string
    hasQuery = url.indexOf('?');
    if (hasQuery !== -1) {
      req.__querystr = url.substr(hasQuery + 1);
      url = url.substr(0, hasQuery);
    }
    // router path
    req.__querypath = url;
    // pass res
    req.__res = res;
    // pass config;
    req.__config = config;
    // set view
    res.__view = view;
    // set reqtimeout
    req.connection.setTimeout(timeout);
    // filter
    filter(req, res, config, function (bool) {
      // if filter return  false , stop response user's request
      if (bool === false) {
        return false;
      }
      var tmp, rule;
      try {
        for (rule in matches) {
          tmp = matches[rule];
          if (tmp[0].test(url)) {
            output('url match :', tmp[0]);
            tmp[1](req, res, config);
            flag = true;
            break;
          }
        }
        // not found page
        if (!flag) {
          named['404'](req, res, config);
        }
      } catch (e) {
        e.message = 'url:' + req.url + e.message;
        req.error = e;
        named['500'](req, res, config, e);
        output(e.message, e.stack);
      }
    });
  };
}

/**
 * create a Server
 * @param  {} cfg
 * @return {}
 */
exports.create = function (cfg) {
  return new Server(cfg);
};
// export Server object
exports.Server = Server;
